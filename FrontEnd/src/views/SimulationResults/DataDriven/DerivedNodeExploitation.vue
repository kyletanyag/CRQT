<template>
<div>
  <result-header 
    title="Derived Node Exploitation Scenario"
    nextPage="Data Driven Results - Recommendations"
    prevPage="Data Driven Results - Network Visualization"
    defaultPage="Data Driven Results"
  />
  <div v-if="error" class="alert alert-danger">
    {{ error }}
  </div>
  <div class="mx-5 row">
    <div class="col text-left">
      <div>
        <h2>Derived Fact Node Severity Statistics</h2>
        <p>
          The graph to the right shows a histogram of all the computed probabilities of every <strong>derived fact</strong> node in the network.
        </p>
        <p>
          Your network has a total of <strong>{{ derivedFact.num }} </strong> derived fact nodes. The breakdown of the derived fact nodes are as followed:
          <br>
          <strong>{{ execCode.percentage }}%</strong> of derived fact nodes or
          <strong>{{ execCode.num }}</strong> nodes in your network contain <strong>code execution capabilities</strong>: execCode().
          <br>
          <strong>{{ netAccess.percentage }}%</strong> of derived fact nodes or
          <strong>{{ netAccess.num }}</strong> nodes in your network <strong>allow for network access</strong>: netAccess().
          <br>
          <strong>{{ canAccess.percentage }}%</strong> of derived fact nodes or
          <strong>{{ canAccess.num }}</strong> nodes in your network have the <strong>ability to access the host</strong>: canAccessHost().
          <br>
          <strong>{{ principalCompromised.percentage }}%</strong> of derived fact nodes or
          <strong>{{ principalCompromised.num }}</strong> nodes in your network can have a <strong>compromised principal</strong>: principalCompromised().
          <br>
          <strong>{{ taskImpact.percentage }}%</strong> of derived fact nodes or
          <strong>{{ taskImpact.num }}</strong> nodes in your network if reached will <strong>impact node tasking</strong>: taskImpact().
          <br>
        </p>
      </div>
    </div>
    <div class="col" v-if="!loadingDerivedScores">
      <!-- Still need to be able to define bin size -->
      <Histogram
        :data="histogramNodeData" 
        :numBins="3"
        :binNames="['Low', 'Medium', 'High']" 
        :name="histogramNodeName" 
        :binLimits="[0.4, 0.7, 1]"
          yAxis="Frequency"
          xAxis="Severity Level"
        barColor='#f87979'
        style="width: 50%"
        class="container"
      />
      <div class="btn-group btn-group-toggle pt-2">
        <label class="btn btn-secondary" :class="{active: histogramNodeType === 'All'}">
          <input type="radio" v-model="histogramNodeType" value="All" autocomplete="off"> All
        </label>
        <label class="btn btn-secondary" :class="{active: histogramNodeType === 'Exec Code'}">
          <input type="radio" v-model="histogramNodeType" value="Exec Code"  autocomplete="off"> Exec Code
        </label>
      </div>
    </div>    
  </div>
  <div class="mx-5 mb-4 row">
    <div class="col">
      <div class="text-left">
        <h2>Derived Fact Node Conditions and Rules Statistics</h2>
        <p>
          Average number of conditions to reach a derived fact node: <strong>{{ avgNumConditions }}</strong>.
          <br>
          Average number of rules to reach a derived fact node: <strong>{{ avgNumRules }}</strong>.
        </p>
      </div>
      <div class="row pt-5">
        <Histogram v-if="!loading"
          :data="histogramCondData"
          :numBins="5"
          :range="[Math.min(...histogramCondData), Math.max(...histogramCondData)]"
          :name="histogramCondName"
          yAxis="Frequency"
          xAxis="Number of Conditions"
          barColor='#f87979'
          style="width: 50%"
          class="col"
        />
        <Histogram v-if="!loading"
          :data="histogramRuleData"
          :numBins="5"
          :range="[Math.min(...histogramRuleData), Math.max(...histogramRuleData)]"
          :name="histogramRuleName"
          yAxis="Frequency"
          xAxis="Number of Rules"
          barColor='#f87979'
          style="width: 50%"
          class="col"
        />
      </div>
      <div class="btn-group btn-group-toggle pt-2">
        <label class="btn btn-secondary" :class="{active: histogramType === 'All'}">
          <input type="radio" v-model="histogramType" value="All" autocomplete="off"> All
        </label>
        <label class="btn btn-secondary" :class="{active: histogramType === 'Exec Code'}">
          <input type="radio" v-model="histogramType" value="Exec Code"  autocomplete="off"> Exec Code
        </label>
      </div>
    </div>
    <div class="col pt-5">
      <div style="overflow-y: auto; height: 600px;">
        <table v-if="data" class="table table-hover">
          <thead>
            <tr>
              <th @click="sort('id')" scope="col">ID<i :class="sortDirection('id')"></i></th>
              <th @click="sort('description')" scope="col">Description<i :class="sortDirection('description')"></i></th>
              <th @click="sort('numConds')" scope="col"># Conditions<i :class="sortDirection('numConds')"></i></th>
              <th @click="sort('numRules')" scope="col"># Rules<i :class="sortDirection('numRules')"></i></th>
            </tr>
          </thead>
            <tbody class="text-center">
              <tr v-for="(node, index) in sortedData" :key="index">
                <td>{{ node.id }}</td>
                <td>{{ node.description }}</td>
                <td>{{ node.num_conditions }}</td>
                <td>{{ node.num_rules }}</td>
              </tr>
            </tbody>
        </table>
      </div>
    </div>
  </div>
</div>
</template>
<script>
import http from '@/http-common.js';
import ResultHeader from '@/components/ResultHeader.vue';
import Histogram from '@/components/Histogram.vue';
export default {
  name: 'Data Driven Results - Derived Node Exploitation',

  components: {
    ResultHeader,
    Histogram
  },

  data() {
    return {
      error: undefined,
      histogramNodeData: [],
      histogramNodeType: 'All',
      execCode: {num: 0, percentage: 0, scores: [], rules: [], conds: []},
      netAccess: {num: 0, percentage: 0, scores: []},
      canAccess: {num: 0, percentage: 0, scores: []},
      principalCompromised: {num: 0, percentage: 0, scores: []},
      taskImpact: {num: 0, percentage: 0, scores: []},
      derivedFact: {num: 0, scores: []},
      loadingDerivedScores: true,
      data: [],
      rules: [],
      avgNumConditions: 0,
      avgNumRules: 0,
      currentSort: 'id',
      currentSortDir: 'asc',
      condVals: [],
      ruleVals: [],
      histogramType: 'All',
      histogramCondData: [],
      histogramRuleData: [],
      loading: true,
    }
  },

  created() {
    this.GetData()
  },

  methods: {
    GetData() {
      this.loadingDerivedScores = true;
      http.get('data_driven/get_derived_scores').then((r) => {
        console.log(r);
        var derivedFactNodes = r.data.nodes.filter((n) => {return n.node_type === 'Derived Fact'});
        this.derivedFact.num = derivedFactNodes.length;

        derivedFactNodes.forEach((n) => {
          this.derivedFact.scores.push(n.base_score);
          if (n.description.includes('execCode')) this.execCode.scores.push(n.base_score);
          else if (n.description.includes('netAccess')) this.netAccess.scores.push(n.base_score);
          else if (n.description.includes('canAccessHost')) this.canAccess.scores.push(n.base_score);
          else if (n.description.includes('principalCompromised')) this.principalCompromised.scores.push(n.base_score);
          else if (n.description.includes('taskImpact')) this.taskImpact.scores.push(n.base_score);
        });

        this.execCode.num = this.execCode.scores.length;
        this.execCode.percentage = Math.round(this.execCode.num / this.derivedFact.num * 100);
        this.netAccess.num = this.netAccess.scores.length;
        this.netAccess.percentage = Math.round(this.netAccess.num / this.derivedFact.num * 100);
        this.canAccess.num = this.canAccess.scores.length;
        this.canAccess.percentage = Math.round(this.canAccess.num / this.derivedFact.num * 100);
        this.principalCompromised.num = this.principalCompromised.scores.length;
        this.principalCompromised.percentage = Math.round(this.principalCompromised.num / this.derivedFact.num * 100);
        this.taskImpact.num = this.taskImpact.scores.length;
        this.taskImpact.percentage = Math.round(this.taskImpact.num / this.derivedFact.num * 100);

        this.histogramNodeData = this.derivedFact.scores;
        this.loadingDerivedScores = false;
      }).catch((e) => {
        this.error = e;
      });

      this.loading = true;
      http.get('/data_driven/conditions_and_rules_per_node').then((r) => {
        this.data = r.data.derived_data;
        
        this.data.forEach((n) => {
          this.condVals.push(n.num_conditions);
        });
        
        this.data.forEach((n) => {
          this.ruleVals.push(n.num_rules);
        });
        
        this.data.filter((n) => { return n.description.includes('execCode')}).forEach((n) => {
          this.execCode.rules.push(n.num_rules);
          this.execCode.conds.push(n.num_conditions);
        })

        this.histogramCondData = this.condVals;
        this.histogramRuleData = this.ruleVals;

        this.avgNumConditions = this.condVals.reduce((a, b) => a + b) / this.condVals.length;
        this.avgNumRules = this.ruleVals.reduce((a, b) => a + b) / this.ruleVals.length;
        this.loading = false;
      }).catch((e) => {
        this.error = e;
      });
    },

    sort(s) {
      if (s === this.currentSort) {
        this.currentSortDir = this.currentSortDir ==='asc' ? 'desc':'asc';
      }
      this.currentSort = s;
    },

    sortDirection(s) {
      if (this.currentSortDir === 'asc' && s === this.currentSort)
        return 'fa fa-fw fa-sort-asc';
      else if (this.currentSortDir === 'desc' && s === this.currentSort)
        return 'fa fa-fw fa-sort-desc';
      else
        return 'fa fa-fw fa-sort';
    },
  },

  computed: {
    sortedData() {
      if (!this.data) return 0;
      return this.data.slice(0).sort((a,b) => {
        let modifier = 1;
        if(this.currentSortDir === 'desc') modifier = -1;
        if(a[this.currentSort] < b[this.currentSort]) return -1 * modifier;
        if(a[this.currentSort] > b[this.currentSort]) return 1 * modifier;
        return 0;
      });
    },

    histogramCondName() {
      if (this.histogramType === 'All') return 'Node Conditions Histogram (All Derived Fact Nodes)';
      else return 'Node Conditions Histogram (Exec Code Nodes)';
    },

    histogramRuleName() {
      if (this.histogramType === 'All') return 'Node Rules Histogram (All Derived Fact Nodes)';
      else return 'Node Rules Histogram (Exec Code Nodes)';
    },

    histogramNodeName() {
      if (this.histogramNodeType === 'All')
        return 'Node Severity Histogram (All Derived Fact Nodes)';
      else
        return 'Node Severity Histogram (Exec Code Nodes)';
    },
  },

  watch: {
    histogramNodeType(type) {
      if (type === 'All')
        this.histogramNodeData = this.derivedFact.scores;
      else
        this.histogramNodeData = this.execCode.scores;
    },
    
    histogramType(type) {
      if (type === 'All') {
        this.histogramRuleData = this.ruleVals;
        this.histogramCondData = this.condVals;
      } else {
        this.histogramRuleData = this.execCode.rules;
        this.histogramCondData = this.execCode.conds;
      }
    },
  },
}
</script>
<style>
</style>